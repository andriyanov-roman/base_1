Зачем нужны абстрактные классы  (http://java-course.ru/begin/abstract/)
Идея абстрактного класса заключается в следующем предположении – для работы иногда вам требуются не
полностью готовые классы, а “заготовки” (полуфабрикаты, если хотите). Они уже кое-что умеют, но в
“сыром виде” их использовать нельзя. Причем здесь стоит выделить два момента:

Создать экземпляр такого класса нельзя
Такой класс требует доработки под какие-либо конкретные условия.
Например в Java есть весьма наглядный класс java.util.Calendar. В его арсенале достаточно много
полезных и нужных функций, но есть одна особенность – он не реализует какой-то конкретный календарь.
Думаю, вы знакомы с тем фактом, что на Земле люди живут по разным календарям. Светские власти и католики
живут по Григорианскому календарю. Русская православная церковь живет по Юлианскому календарю. А если
ваша программа будет работает на марсоходе (что на самом деле так и есть – Java работает на марсоходе Spirit),
то ей придется учитывать марсианский календарь. Как вы понимаете календари имеют различия, но вряд ли вы
удивитесь, если вам скажут, что возможность прибавить 5 дней к какой-либо дате должна присутствовать во
всех вариантах. Т.е. во всех этих календарях есть общий набор функций, который может иметь одинаковую
реализацию. Отсюда рождается идея абстрактного класса, который с одной стороны не может создавать объекты,
а с другой стороны, может иметь уже готовые функции.
Еще одним примером абстрактного класса может служить уже знакомый нам класс JComponent. Этот класс умеет
многое, он только не умеет рисовать что-либо. И если его этому научить – создать класс на его основе и
переопределить метод paintComponent, то мы получим то, что нам надо.
Создание абстрактного класса на самом деле достаточно сложная архитектурная задача. Необходимость использовать
именно абстрактный класс проявляется не сразу. Требуется провести анализ задачи и набора классов, который
позволит принять решение.
А вот техническая сторона достаточно простая – для объявления абстрактного класса достаточно добавить ключевое
слово abstract в описании класса.

abstract public class AbstractModel {
...
}

Если вы попробуете создать объект этого класса, то компилятор выдаст сообщение об ошибке.
Кроме того, что мы можем заставить разработчика НЕ пользоваться нашим классом впрямую, мы можем еще
более жестко подойти к наследованию – установить правила, которые заставят класс-наследник реализовать
определенные методы.
Для этого необходимо не только класс описать как абстрактный, но и метод, который должен обязательно
реализовать наследник. Форма записи достаточно несложная. Здесь только надо отметить, что тело метода
отсутствует совсем – сразу за описанием метода ставится точка с запятой. Например:

public abstract class AbstractModel
{
   public abstract void processModel();
}

В нашем примере не только класс объявлен как абстрактный, что запрещает создание экземпляра такого класса,
но и требуется переопределить метод processModel.
Внимательный читатель возможно отметил факт, что я в одном случае слово abstract поставил в самом начале,
а в втором примере после слова public. Это сделано специально – я хотело продемонстрировать, что можно делать
объявления и так и так.

И наконец мы сделаем более сложный пример, который продемонстрирует использование абстрактного класса.
В части Полиморфизм мы создали приложение, которое рисовало на форме три вида фигур: треугольник, прямоугольник,
овал. В этом приложении мы использовали абстрактный класс JComponent, который не имеет обязательности для
переопределения метода для рисования paintComponent. Создадим абстрактный класс, который наследуется от
JComponent и имеет абстрактный метод, который надо переопределить в классах-наследниках. Вот такой класс:

package edu.javacourse.ui.component;

import java.awt.Graphics;
import javax.swing.JComponent;

public abstract class AbstractShape extends JComponent
{
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        paintShape(g);
    }

    abstract protected void paintShape(Graphics g);
}
Как видим теперь наш класс не просто абстрактный и значит не может быть создан объект такого класса, но
также необходимо переопределить метод paintShape. Напишем реализацию наших классов для треугольника, овала
и прямоугольника:

Треугольник

package edu.javacourse.ui.component;

import java.awt.Graphics;

// Класс для рисования треугольника
public class TriangleComponent extends AbstractShape
{
    @Override
    protected void paintShape(Graphics g) {
        g.drawLine(5, getHeight() - 10, getWidth() / 2 - 5, 5);
        g.drawLine(getWidth() / 2 - 5, 5, getWidth() - 10, getHeight() - 10);
        g.drawLine(getWidth() - 10, getHeight() - 10, 5, getHeight() - 10);
    }
}

Прямоугольник

package edu.javacourse.ui.component;

import java.awt.Graphics;

// Класс для рисования прямоугольника
public class RectangleComponent extends AbstractShape
{
    @Override
    protected void paintShape(Graphics g) {
        g.drawRect(5, 5, getWidth() - 10, getHeight() - 10);
    }
}

Овал

package edu.javacourse.ui.component;

import java.awt.Graphics;

// Класс для рисования овала
public class OvalComponent extends AbstractShape
{
    @Override
    protected void paintShape(Graphics g) {
        g.drawOval(5, 5, getWidth() - 10, getHeight() - 10);
    }
}
Класс для формы

package edu.javacourse.ui;

import edu.javacourse.ui.component.OvalComponent;
import edu.javacourse.ui.component.RectangleComponent;
import edu.javacourse.ui.component.TriangleComponent;
import java.awt.GridLayout;
import javax.swing.JFrame;

public class ShapeFrame extends JFrame
{
    public ShapeFrame() {
        // Устанавливаем LayoutManager в виде таблицы
        // размерами 2 строки на 3 столбца
        setLayout(new GridLayout(2, 3));

        // Создаем и "укладываем" на форму компоненты разных классов
        add(new OvalComponent());
        add(new RectangleComponent());
        add(new TriangleComponent());
        add(new OvalComponent());
        add(new RectangleComponent());
        add(new TriangleComponent());

        // Устанавливаем координаты и размеры окна
        setBounds(200, 200, 450, 350);
    }
}
В конце класс для запуска нашего приложения

package edu.javacourse.ui;

import javax.swing.JFrame;

public class ShapeApplication
{
    public static void main(String[] args) {
        // Создаем графическое окно
        ShapeFrame of = new ShapeFrame();
        // Задаем правидо, по которому приложение завершиться при
        // закрытии этой формы
        of.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        // Делаем окно видимым
        of.setVisible(true);
    }
}
Скачать наше приложение можно по ссылке: ShapeApplication2.
Для первого знакомства с абстрактными классами информации будет достаточно. Позволю еще раз отметить: абстрактные
классы являются дополнительным удобством при проектировании иерархии классов и позволяют более строго подходить к
этому вопросу. Возможно, что на данном этапе изучения вы не полностью осознаете их полезность, но при накоплении
опыта вы наверняка поймете и оцените удобство их использования.